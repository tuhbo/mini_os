
### 加载内核

从磁盘中读取内核文件（用C语言编写生成的ELF文件）加载到内存中

### 初始化内核文件

加载到内核中的文件，还不能执行；在分页机制下，解析内核ELF文件（即把ELF文件展开到对用的虚拟地址），即内存中需要保存内核ELF文件展开后的各种段segment。（这个才是真正运行的内核镜像）


* 从开机到内核运行整个流程

BIOS->MBR->loader(保护模式，读取磁盘，分页等)-》kernel

内核镜像文件运行时有一个入口虚拟地址，loader解析完kernel,并载入内存中，然后jmp到kernel的入口地址，完成kernel的执行


### 管理内存

* 内存的物理大小可以通过BIOS相关操作得到；

* 低1M的物理内存，每个区域有各自的用途，除分段，分页相关和必要的物理内存（内存管理本身如位图相关），其它空闲物理内存做位图管理（包括内核的物理内存池，和用户空间的物理内存池）。然后对应到分页机制上，实现分配虚拟页的相关功能，虚拟地址到物理地址映射等

### 各种打印函数的实现

* 低1M的物理内存中有相应的文本显示内存段，只需要操作该内存就能完成显示相关的操作；用汇编加上C语言的形式，封装成打印函数即可。


### 内核线程

* 线程作为可以独立执行的指令流，可以被CPU调度（需要设计线程的数据结构和相关的构造，执行等函数）

* call, ret指令可用来实现线程的切换

* 多线程调度

线程运行有ticks，状态可以改变，也有优先级；可以设计一个简单的优先级调度，用链表存储先关的线程（就绪队列，阻塞队列）


### 线程同步 -- 信号量，锁

锁用二元信号量来实现

二元信号量的P,V操作用中断来实现，即用中断实现原子操作（比如关闭中断，执行操作，再回复现场，那么该操作不会被其它事件打扰，是个原子性操作）


### 用户进程

* 进程是需要占用资源的，所以需要分配页内存

* 用户进程拥有4G的虚拟地址空间（3G用户进程特有，1G是内核公有的），所以分页时也是按照此规则分配

* 仿照内核线程，设计实现用户进程，并完成调度


### malloc

* 分页分配整数个页内存，粒度太大，可以把粒度变小一点，分配如8B, 16B, 32B,64B的这种块内存

* 需要设计数据结构arena, 描述一个大内存，用这种小粒度来表示

* malloc 分配特定字节大小的内存












